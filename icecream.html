<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Cream?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a0a2e 0%, #2d1b4e 50%, #1a0a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        h1 {
            color: #ff6ec7;
            font-size: 4rem;
            margin-top: 40px;
            text-shadow:
                0 0 10px #ff6ec7,
                0 0 20px #ff6ec7,
                0 0 40px #ff6ec7,
                0 0 80px #ff6ec7;
            letter-spacing: 8px;
            animation: glow 2s ease-in-out infinite alternate;
            z-index: 10;
            position: relative;
        }

        @keyframes glow {
            from {
                text-shadow:
                    0 0 10px #ff6ec7,
                    0 0 20px #ff6ec7,
                    0 0 40px #ff6ec7;
            }
            to {
                text-shadow:
                    0 0 20px #ff6ec7,
                    0 0 40px #ff6ec7,
                    0 0 60px #ff6ec7,
                    0 0 100px #ff6ec7;
            }
        }

        #canvas-container {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <h1>ice cream?</h1>
    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight - 120);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        // Orbit controls for dragging with momentum
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.8;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff6ec7, 2, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x9b59b6, 1.5, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xffffff, 1, 100);
        pointLight3.position.set(0, 0, 10);
        scene.add(pointLight3);

        // Ice cream cone group
        const iceCreamGroup = new THREE.Group();

        // Soft cloudy white aura using sprite with radial gradient
        const auraCanvas = document.createElement('canvas');
        auraCanvas.width = 512;
        auraCanvas.height = 512;
        const ctx = auraCanvas.getContext('2d');

        // Create smooth radial gradient for cloudy effect
        const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.25)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.03)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        const auraTexture = new THREE.CanvasTexture(auraCanvas);
        const auraMaterial = new THREE.SpriteMaterial({
            map: auraTexture,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const auraSprite = new THREE.Sprite(auraMaterial);
        auraSprite.scale.set(12, 12, 1);
        auraSprite.position.y = 1;
        scene.add(auraSprite);

        // Cone
        const coneGeometry = new THREE.ConeGeometry(1, 2.5, 32);
        const coneMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            roughness: 0.8,
            metalness: 0.1
        });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.y = -1.5;
        cone.rotation.x = Math.PI;
        iceCreamGroup.add(cone);

        // Ice cream scoops - glossy materials
        const scoopMaterial1 = new THREE.MeshPhysicalMaterial({
            color: 0xff6ec7,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: 0xff6ec7,
            emissiveIntensity: 0.1
        });

        const scoopMaterial2 = new THREE.MeshPhysicalMaterial({
            color: 0x9b59b6,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: 0x9b59b6,
            emissiveIntensity: 0.1
        });

        const scoopMaterial3 = new THREE.MeshPhysicalMaterial({
            color: 0xf8bbd9,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: 0xf8bbd9,
            emissiveIntensity: 0.1
        });

        // Bottom scoop
        const scoop1Geometry = new THREE.SphereGeometry(1.1, 32, 32);
        const scoop1 = new THREE.Mesh(scoop1Geometry, scoopMaterial1);
        scoop1.position.y = 0.3;
        iceCreamGroup.add(scoop1);

        // Middle scoop
        const scoop2Geometry = new THREE.SphereGeometry(1, 32, 32);
        const scoop2 = new THREE.Mesh(scoop2Geometry, scoopMaterial2);
        scoop2.position.y = 1.5;
        iceCreamGroup.add(scoop2);

        // Top scoop
        const scoop3Geometry = new THREE.SphereGeometry(0.85, 32, 32);
        const scoop3 = new THREE.Mesh(scoop3Geometry, scoopMaterial3);
        scoop3.position.y = 2.5;
        iceCreamGroup.add(scoop3);

        // Cherry on top - glossy
        const cherryGeometry = new THREE.SphereGeometry(0.25, 32, 32);
        const cherryMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xff1744,
            roughness: 0.05,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.05
        });
        const cherry = new THREE.Mesh(cherryGeometry, cherryMaterial);
        cherry.position.y = 3.3;
        iceCreamGroup.add(cherry);

        // Cherry stem
        const stemCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 3.5, 0),
            new THREE.Vector3(0.1, 3.7, 0.05),
            new THREE.Vector3(0.05, 3.9, 0)
        ]);
        const stemGeometry = new THREE.TubeGeometry(stemCurve, 20, 0.03, 8, false);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        iceCreamGroup.add(stem);

        // Add sprinkles using small cylinders
        const sprinkleColors = [0xff6ec7, 0x00ffff, 0xffff00, 0xff4444, 0x44ff44];
        for (let i = 0; i < 40; i++) {
            const sprinkleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8);
            const sprinkleMaterial = new THREE.MeshStandardMaterial({
                color: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)],
                emissive: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)],
                emissiveIntensity: 0.4
            });
            const sprinkle = new THREE.Mesh(sprinkleGeometry, sprinkleMaterial);

            // Random position on scoops
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.6 + 0.2;
            const scoopIndex = Math.floor(Math.random() * 3);
            const radius = [1.12, 1.02, 0.87][scoopIndex];
            const yOffset = [0.3, 1.5, 2.5][scoopIndex];

            sprinkle.position.x = radius * Math.sin(phi) * Math.cos(theta);
            sprinkle.position.z = radius * Math.sin(phi) * Math.sin(theta);
            sprinkle.position.y = yOffset + radius * Math.cos(phi) * 0.5;

            sprinkle.rotation.x = Math.random() * Math.PI;
            sprinkle.rotation.z = Math.random() * Math.PI;

            iceCreamGroup.add(sprinkle);
        }

        scene.add(iceCreamGroup);

        camera.position.z = 7;
        camera.position.y = 1;

        // Animation with momentum spinning
        let isInteracting = false;
        let previousAzimuth = 0;
        let spinVelocity = 0.008;

        controls.addEventListener('start', () => {
            isInteracting = true;
            previousAzimuth = controls.getAzimuthalAngle();
        });

        controls.addEventListener('change', () => {
            if (isInteracting) {
                const currentAzimuth = controls.getAzimuthalAngle();
                spinVelocity = (currentAzimuth - previousAzimuth) * 0.5;
                previousAzimuth = currentAzimuth;
            }
        });

        controls.addEventListener('end', () => {
            isInteracting = false;
        });

        function animate() {
            requestAnimationFrame(animate);

            // Apply spin momentum when not interacting
            if (!isInteracting) {
                iceCreamGroup.rotation.y += spinVelocity;
                // Gradually slow down but keep minimum rotation
                spinVelocity *= 0.995;
                if (Math.abs(spinVelocity) < 0.005) {
                    spinVelocity = 0.005 * Math.sign(spinVelocity || 1);
                }
            }

            // Gentle floating motion
            iceCreamGroup.position.y = Math.sin(Date.now() * 0.001) * 0.2;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 120);
        });
    </script>
</body>
</html>

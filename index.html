<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ice Cream?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a0a2e 0%, #2d1b4e 50%, #1a0a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        h1 {
            color: #ff6ec7;
            font-size: 4rem;
            margin-top: 40px;
            text-align: center;
            width: 100%;
            text-shadow:
                0 0 10px #ff6ec7,
                0 0 20px #ff6ec7,
                0 0 40px #ff6ec7,
                0 0 80px #ff6ec7;
            letter-spacing: 8px;
            animation: glow 2s ease-in-out infinite alternate;
            z-index: 10;
            position: relative;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2.5rem;
                letter-spacing: 4px;
                margin-top: 30px;
            }
        }

        @keyframes glow {
            from {
                text-shadow:
                    0 0 10px #ff6ec7,
                    0 0 20px #ff6ec7,
                    0 0 40px #ff6ec7;
            }
            to {
                text-shadow:
                    0 0 20px #ff6ec7,
                    0 0 40px #ff6ec7,
                    0 0 60px #ff6ec7,
                    0 0 100px #ff6ec7;
            }
        }

        #canvas-container {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        .hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: lowercase;
            opacity: 1;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 10;
        }

        .hint.hidden {
            opacity: 0;
        }

        @media (max-width: 600px) {
            .hint {
                font-size: 0.8rem;
                bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <h1>ice cream?</h1>
    <div id="canvas-container"></div>
    <p class="hint">drag to spin</p>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight - 100);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        // Lighting - brighter and more visible
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff6ec7, 3, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x9b59b6, 2, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xffffff, 2, 100);
        pointLight3.position.set(0, 0, 10);
        scene.add(pointLight3);

        const backLight = new THREE.PointLight(0xffffff, 1.5, 100);
        backLight.position.set(0, 0, -10);
        scene.add(backLight);

        // Ice cream cone group
        const iceCreamGroup = new THREE.Group();

        // Soft cloudy white aura - positioned BEHIND the ice cream
        const auraCanvas = document.createElement('canvas');
        auraCanvas.width = 512;
        auraCanvas.height = 512;
        const ctx = auraCanvas.getContext('2d');

        // Create smooth radial gradient for cloudy effect - brighter
        const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.6)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.35)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        const auraTexture = new THREE.CanvasTexture(auraCanvas);
        const auraMaterial = new THREE.SpriteMaterial({
            map: auraTexture,
            transparent: true,
            opacity: 0.8,
            depthWrite: false
        });
        const auraSprite = new THREE.Sprite(auraMaterial);
        auraSprite.scale.set(14, 14, 1);
        auraSprite.position.set(0, 1, -3);
        scene.add(auraSprite);

        // Cone
        const coneGeometry = new THREE.ConeGeometry(1, 2.5, 32);
        const coneMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            roughness: 0.6,
            metalness: 0.1
        });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.y = -1.5;
        cone.rotation.x = Math.PI;
        iceCreamGroup.add(cone);

        // Ice cream scoops - brighter, glossier materials
        const scoopMaterial1 = new THREE.MeshPhysicalMaterial({
            color: 0xff7ed4,
            roughness: 0.15,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.1,
            emissive: 0xff6ec7,
            emissiveIntensity: 0.25
        });

        const scoopMaterial2 = new THREE.MeshPhysicalMaterial({
            color: 0xb06ec7,
            roughness: 0.15,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.1,
            emissive: 0x9b59b6,
            emissiveIntensity: 0.25
        });

        const scoopMaterial3 = new THREE.MeshPhysicalMaterial({
            color: 0xffc8e8,
            roughness: 0.15,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.1,
            emissive: 0xf8bbd9,
            emissiveIntensity: 0.25
        });

        // Bottom scoop
        const scoop1Geometry = new THREE.SphereGeometry(1.1, 32, 32);
        const scoop1 = new THREE.Mesh(scoop1Geometry, scoopMaterial1);
        scoop1.position.y = 0.3;
        iceCreamGroup.add(scoop1);

        // Middle scoop
        const scoop2Geometry = new THREE.SphereGeometry(1, 32, 32);
        const scoop2 = new THREE.Mesh(scoop2Geometry, scoopMaterial2);
        scoop2.position.y = 1.5;
        iceCreamGroup.add(scoop2);

        // Top scoop
        const scoop3Geometry = new THREE.SphereGeometry(0.85, 32, 32);
        const scoop3 = new THREE.Mesh(scoop3Geometry, scoopMaterial3);
        scoop3.position.y = 2.5;
        iceCreamGroup.add(scoop3);

        // Cherry on top - glossy
        const cherryGeometry = new THREE.SphereGeometry(0.25, 32, 32);
        const cherryMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xff3366,
            roughness: 0.05,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.05,
            emissive: 0xff1744,
            emissiveIntensity: 0.2
        });
        const cherry = new THREE.Mesh(cherryGeometry, cherryMaterial);
        cherry.position.y = 3.3;
        iceCreamGroup.add(cherry);

        // Cherry stem
        const stemCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 3.5, 0),
            new THREE.Vector3(0.1, 3.7, 0.05),
            new THREE.Vector3(0.05, 3.9, 0)
        ]);
        const stemGeometry = new THREE.TubeGeometry(stemCurve, 20, 0.03, 8, false);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        iceCreamGroup.add(stem);

        // Add sprinkles using small cylinders
        const sprinkleColors = [0xff6ec7, 0x00ffff, 0xffff00, 0xff4444, 0x44ff44];
        for (let i = 0; i < 40; i++) {
            const sprinkleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8);
            const sprinkleMaterial = new THREE.MeshStandardMaterial({
                color: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)],
                emissive: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)],
                emissiveIntensity: 0.5
            });
            const sprinkle = new THREE.Mesh(sprinkleGeometry, sprinkleMaterial);

            // Random position on scoops
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.6 + 0.2;
            const scoopIndex = Math.floor(Math.random() * 3);
            const radius = [1.12, 1.02, 0.87][scoopIndex];
            const yOffset = [0.3, 1.5, 2.5][scoopIndex];

            sprinkle.position.x = radius * Math.sin(phi) * Math.cos(theta);
            sprinkle.position.z = radius * Math.sin(phi) * Math.sin(theta);
            sprinkle.position.y = yOffset + radius * Math.cos(phi) * 0.5;

            sprinkle.rotation.x = Math.random() * Math.PI;
            sprinkle.rotation.z = Math.random() * Math.PI;

            iceCreamGroup.add(sprinkle);
        }

        scene.add(iceCreamGroup);

        camera.position.z = 7;
        camera.position.y = 1;

        // Custom drag rotation with full freedom (no polar limits)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0.008 };
        const quaternion = new THREE.Quaternion();
        const rotationAxis = new THREE.Vector3();

        function getPointerPosition(event) {
            if (event.touches && event.touches.length > 0) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        const hint = document.querySelector('.hint');

        function onPointerDown(event) {
            isDragging = true;
            const pos = getPointerPosition(event);
            previousMousePosition = { x: pos.x, y: pos.y };
            rotationVelocity = { x: 0, y: 0 };

            // Hide hint after first interaction
            if (hint && !hint.classList.contains('hidden')) {
                hint.classList.add('hidden');
            }
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            const pos = getPointerPosition(event);
            const deltaX = pos.x - previousMousePosition.x;
            const deltaY = pos.y - previousMousePosition.y;

            // Rotate based on drag - sensitivity increased for easier control
            const rotateSpeed = 0.008;

            // Horizontal drag rotates around world Y axis
            rotationAxis.set(0, 1, 0);
            quaternion.setFromAxisAngle(rotationAxis, deltaX * rotateSpeed);
            iceCreamGroup.quaternion.premultiply(quaternion);

            // Vertical drag rotates around world X axis
            rotationAxis.set(1, 0, 0);
            quaternion.setFromAxisAngle(rotationAxis, deltaY * rotateSpeed);
            iceCreamGroup.quaternion.premultiply(quaternion);

            // Store velocity for momentum
            rotationVelocity.x = deltaY * rotateSpeed * 0.5;
            rotationVelocity.y = deltaX * rotateSpeed * 0.5;

            previousMousePosition = { x: pos.x, y: pos.y };
        }

        function onPointerUp() {
            isDragging = false;
        }

        // Mouse events
        renderer.domElement.addEventListener('mousedown', onPointerDown);
        renderer.domElement.addEventListener('mousemove', onPointerMove);
        renderer.domElement.addEventListener('mouseup', onPointerUp);
        renderer.domElement.addEventListener('mouseleave', onPointerUp);

        // Touch events
        renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: true });
        renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: true });
        renderer.domElement.addEventListener('touchend', onPointerUp);
        renderer.domElement.addEventListener('touchcancel', onPointerUp);

        function animate() {
            requestAnimationFrame(animate);

            // Apply momentum when not dragging
            if (!isDragging) {
                // Apply rotation momentum
                if (Math.abs(rotationVelocity.y) > 0.0001 || Math.abs(rotationVelocity.x) > 0.0001) {
                    rotationAxis.set(0, 1, 0);
                    quaternion.setFromAxisAngle(rotationAxis, rotationVelocity.y);
                    iceCreamGroup.quaternion.premultiply(quaternion);

                    rotationAxis.set(1, 0, 0);
                    quaternion.setFromAxisAngle(rotationAxis, rotationVelocity.x);
                    iceCreamGroup.quaternion.premultiply(quaternion);
                }

                // Gradually slow down
                rotationVelocity.x *= 0.98;
                rotationVelocity.y *= 0.98;

                // Keep a minimum gentle Y rotation
                if (Math.abs(rotationVelocity.y) < 0.003 && Math.abs(rotationVelocity.x) < 0.001) {
                    rotationVelocity.y = 0.005;
                }
            }

            // Gentle floating motion
            iceCreamGroup.position.y = Math.sin(Date.now() * 0.001) * 0.2;

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 100);
        });
    </script>
</body>
</html>
